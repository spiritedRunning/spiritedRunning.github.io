<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.3.6">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="原文地址 简介MediaCodec类可以获取底层媒体编码/解码库，是Android底层多媒体支持库的一部分（一般和MediaExtractor(api 16)、MediaSync(api 23)、MediaMuxer(api 18)、MediaCrypto(api 16)、MediaDrm(api 18)、Image(api 19)、Surface(api 1)、AudioTrack(api 3)">
<meta name="keywords" content="MediaCodeC">
<meta property="og:type" content="article">
<meta property="og:title" content="MediaCodeC API文档">
<meta property="og:url" content="https://spiritedrunning.github.io/2017/09/28/MediaCodeC API 文档/index.html">
<meta property="og:site_name" content="Zach&#39;s Blog">
<meta property="og:description" content="原文地址 简介MediaCodec类可以获取底层媒体编码/解码库，是Android底层多媒体支持库的一部分（一般和MediaExtractor(api 16)、MediaSync(api 23)、MediaMuxer(api 18)、MediaCrypto(api 16)、MediaDrm(api 18)、Image(api 19)、Surface(api 1)、AudioTrack(api 3)">
<meta property="og:image" content="https://i.postimg.cc/pXBt1c9P/Screenshot-2019-07-27-at-15-44-44.png">
<meta property="og:image" content="https://i.postimg.cc/BnqK1vP4/Screenshot-2019-07-27-at-15-44-54.png">
<meta property="og:image" content="https://i.postimg.cc/pL6KbHyv/Screenshot-2019-07-27-at-15-45-02.png">
<meta property="og:image" content="https://i.postimg.cc/tJ8HG70P/Screenshot-2019-07-27-at-15-45-15.png">
<meta property="og:image" content="https://i.postimg.cc/wxNzDcDQ/Screenshot-2019-07-27-at-16-08-39.png">
<meta property="og:image" content="https://i.postimg.cc/wMgwyphP/Screenshot-2019-07-27-at-16-08-48.png">
<meta property="og:image" content="https://i.postimg.cc/TwCD0MzB/Screenshot-2019-07-27-at-16-09-07.png">
<meta property="og:image" content="https://i.postimg.cc/ZRB1J4Th/Screenshot-2019-07-27-at-16-20-36.png">
<meta property="og:image" content="https://i.postimg.cc/6QSmjgCb/Screenshot-2019-07-27-at-16-24-02.png">
<meta property="og:updated_time" content="2019-07-27T13:52:18.039Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MediaCodeC API文档">
<meta name="twitter:description" content="原文地址 简介MediaCodec类可以获取底层媒体编码/解码库，是Android底层多媒体支持库的一部分（一般和MediaExtractor(api 16)、MediaSync(api 23)、MediaMuxer(api 18)、MediaCrypto(api 16)、MediaDrm(api 18)、Image(api 19)、Surface(api 1)、AudioTrack(api 3)">
<meta name="twitter:image" content="https://i.postimg.cc/pXBt1c9P/Screenshot-2019-07-27-at-15-44-44.png">
  <link rel="canonical" href="https://spiritedrunning.github.io/2017/09/28/MediaCodeC API 文档/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>MediaCodeC API文档 | Zach's Blog</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zach's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archives</a>

  </li>
    </ul>
    

</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://spiritedrunning.github.io/2017/09/28/MediaCodeC API 文档/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zach Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zach's Blog">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">MediaCodeC API文档

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-09-28 11:06:10" itemprop="dateCreated datePublished" datetime="2017-09-28T11:06:10+08:00">2017-09-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-27 21:52:18" itemprop="dateModified" datetime="2019-07-27T21:52:18+08:00">2019-07-27</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/翻译/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon"
              >
                <i class="fa fa-eye"></i>
                 Views:  
                <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
              </span>
            </span>
          
            
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="fa fa-comment-o"></i>
    </span>
    
      <span class="post-meta-item-text">Comments: </span>
    
  
    <a href="/2017/09/28/MediaCodeC API 文档/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/09/28/MediaCodeC API 文档/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          <br/>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span title="Symbols count in article">15k</span>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span title="Reading time">13 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://developer.android.com/reference/android/media/MediaCodec" target="_blank" rel="external">原文地址</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MediaCodec类可以获取底层媒体编码/解码库，是Android底层多媒体支持库的一部分（一般和<a href="https://developer.android.com/reference/android/media/MediaExtractor.html" target="_blank" rel="external">MediaExtractor</a>(api 16)、<a href="https://developer.android.com/reference/android/media/MediaSync.html" target="_blank" rel="external">MediaSync</a>(api 23)、<a href="https://developer.android.com/reference/android/media/MediaMuxer.html" target="_blank" rel="external">MediaMuxer</a>(api 18)、<a href="https://developer.android.com/reference/android/media/MediaCrypto.html" target="_blank" rel="external">MediaCrypto</a>(api 16)、<a href="https://developer.android.com/reference/android/media/MediaDrm.html" target="_blank" rel="external">MediaDrm</a>(api 18)、<a href="https://developer.android.com/reference/android/media/Image.html" target="_blank" rel="external">Image</a>(api 19)、<a href="https://developer.android.com/reference/android/view/Surface.html" target="_blank" rel="external">Surface</a>(api 1)、<a href="https://developer.android.com/reference/android/media/AudioTrack.html" target="_blank" rel="external">AudioTrack</a>(api 3)搭配使用）。</p>
<p><img src="https://i.postimg.cc/pXBt1c9P/Screenshot-2019-07-27-at-15-44-44.png" alt=""></p>
<p>宽泛的说，codec（编解码器）通过异步的方式对输入的数据进行处理，输出处理后的数据，过程中需要一系列的输入/输出Buffers。最简单的情况下，先把数据放进一个空的输入buffer（申请或者获取得到）中，发送给codec，codec对数据进行处理转换后放进一个输出buffer中，拿到输出buffer后，自行处理输出buffer中的数据，之后释放输出buffer并返回给codec。<br><a id="more"></a></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>codec可以操作三种数据：压缩过的数据、raw格式audio数据、raw格式video数据。</p>
<p>这三种数据都可以用ByteBuffers进行处理。<br>但是处理raw video数据时，应该使用Surface以增强性能。Surface使用native层buffer，没有经过映射、拷贝到ByteBuffers，所以效率更高。正常情况下，使用Surface时获取不到raw格式的video数据，需要通过ImageReader类获取raw格式的video帧数据，由于native层的buffers可以直接映射为ByteBuffer，所以效率依然很高。<br>当使用ByteBuffer模式时，通过Image类的getInput()/OutputImage(int)方法，就可以得到raw格式的video帧数据。</p>
<h3 id="Compressed-Buffers"><a href="#Compressed-Buffers" class="headerlink" title="Compressed Buffers"></a>Compressed Buffers</h3><p>输入buffers（用于解码器）和输出buffers（用于编码器）根据格式类型包含不同的压缩数据，对于video，buffer中是视频的一帧数据；对于audio来说，一般是一个访问单元（一个典型的编码过的音频片段包含若干毫秒的audio数据），也有可能是多个访问单元的数据。任何情况下，buffer只在帧或者访问单元的边界上开始或结束，不会在任一字符边界开始或者结束, 除非他们被设置了BUFFER_FLAG_PARTIAL_FRAME标志。</p>
<h3 id="Raw-Audio-Buffers"><a href="#Raw-Audio-Buffers" class="headerlink" title="Raw Audio Buffers"></a>Raw Audio Buffers</h3><p>Raw Audio buffers包含了PCM audio数据的整个帧，是音频通道中每个通道的样本。每个样本都是一个用native byte顺序存放的16-bit signed integer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">short[] getSamplesForChannel(MediaCodec codec, int bufferId, int channelIx) &#123;</div><div class="line">  ByteBuffer outputBuffer = codec.getOutputBuffer(bufferId);</div><div class="line">  MediaFormat format = codec.getOutputFormat(bufferId);</div><div class="line">  ShortBuffer samples = outputBuffer.order(ByteOrder.nativeOrder()).asShortBuffer();</div><div class="line">  int numChannels = formet.getInteger(MediaFormat.KEY_CHANNEL_COUNT);</div><div class="line">  if (channelIx &lt; 0 || channelIx &gt;= numChannels) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  short[] res = new short[samples.remaining() / numChannels];</div><div class="line">  for (int i = 0; i &lt; res.length; ++i) &#123;</div><div class="line">    res[i] = samples.get(i * numChannels + channelIx);</div><div class="line">  &#125;</div><div class="line">  return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Raw-Video-Buffers"><a href="#Raw-Video-Buffers" class="headerlink" title="Raw Video Buffers"></a>Raw Video Buffers</h3><p>在ByteBuffer模式下，video buffers是根据其颜色格式存放的，通过getCodeInfo().getCapabilitiesForType(……)可以获取支持的颜色格式数组。Video codecs支持以下三种颜色格式。</p>
<ul>
<li><strong>native raw video format</strong>：通过COLOR_FormatSurface标记的格式，可以与Surface的输入/输出一起使用</li>
<li><strong>flexible YUV buffers</strong>(例如COLOR_FormatYUV420Flexible)：可以同时与Surface的输入/输出和ByteBuffer模式下使用。</li>
<li><strong>other, specific formats</strong>：一般只支持ByteBuffer模式。其中一些是厂家的具体格式，另外的声明在MediaCodecInfo.CodecCapabilities。对于和flexible格式相同的颜色格式，仍然可以使用getInput/OutPutImage(int)。<br>从<code>Android LOLLIPOP_MR1(api 22)</code>开始，所有的video codecs都支持flexible YUV 4:2:0 buffers</li>
</ul>
<h3 id="在老设备上获取Raw-Video-ByteBuffers"><a href="#在老设备上获取Raw-Video-ByteBuffers" class="headerlink" title="在老设备上获取Raw Video ByteBuffers"></a>在老设备上获取Raw Video ByteBuffers</h3><p>在<code>Android LOLLIPOP(api 21)</code>和Image支持之前，需要通过输出格式参数：KEY_STRIDE和DEY_SLICE_HEIGHT来描述raw格式的输出buffers。</p>
<blockquote>
<p>在一些设备上切片高度被标示为0。折意味着切片的高度要么与帧的高度一样，要么与切片的高度的某个值对齐(通常为2的幂)。但是，这种情况下没有一个标准或简单的方法分辨切片的实际高度。而且，U平面竖直方向上的格式也没有被指定或者定义，通常为切片高度的一半。</p>
</blockquote>
<p>参数KEY_WIDTH和KEY_HEIGHT指定video帧的尺寸，但是大多数的编码的video（picture）只是video帧的一部分，由裁剪矩形表示。<br>使用下面一些参数可以获取raw output images的裁剪矩形，这些参数通过outputformat获取。如果这些参数不存在，video将占据整个video帧。在应用任何旋转操作之前，裁剪矩形在输出帧的context中被解释。<br><img src="https://i.postimg.cc/BnqK1vP4/Screenshot-2019-07-27-at-15-44-54.png" alt=""></p>
<p>旋转之前的video帧的尺寸可以通过如下方式计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MediaFormat format = decoder.getOutputFormat(…);</div><div class="line">int width = format.getInteger(MediaFormat.KEY_WIDTH);</div><div class="line">if (format.containsKey(&quot;crop-left&quot;) &amp;&amp; format.containsKey(&quot;crop-right&quot;)) &#123;</div><div class="line">    width = format.getInteger(&quot;crop-right&quot;) + 1 - format.getInteger(&quot;crop-left&quot;);</div><div class="line">&#125;</div><div class="line">int height = format.getInteger(MediaFormat.KEY_HEIGHT);</div><div class="line">if (format.containsKey(&quot;crop-top&quot;) &amp;&amp; format.containsKey(&quot;crop-bottom&quot;)) &#123;</div><div class="line">    height = format.getInteger(&quot;crop-bottom&quot;) + 1 - format.getInteger(&quot;crop-top&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>要注意BufferInfo.offset的含义在不同设备上不一致。在某些设备上，偏移指向裁剪矩形的左上角像素，而在大多数设备上，它指向整个帧的左上角像素。</p>
</blockquote>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>在codec的生命周期中，存在三种状态：</p>
<ul>
<li>Stopped：包含Uninitialized、Configured、Error三种子状态。</li>
<li>Executing：包含Flushed、Running、End-of-Stream三种子状态。</li>
<li>Released</li>
</ul>
<p>MediaCodec状态<br><img src="https://i.postimg.cc/pL6KbHyv/Screenshot-2019-07-27-at-15-45-02.png" alt=""></p>
<p>当用工厂方法创建一个codec时，codec处于Uninitialized状态。首先通过configure(……)方法注册codec，使其处于Configure状态；然后调用start()方法使其进入Executing状态，在这个状态下，就可以通过buffer队列处理数据。<br>Executing有三个子状态：Flushed、Running、End-of-Stream。在调用start()之后codec立即进入Flushed状态，持有所有的buffers；当从buffer队列拿到第一个输入buffer时，codec进入Running状态，codec整个生命周期的大部分时间都处在这个状态；当输入buffer是end-of-stream标示时，codec切换到End-of-Stream状态，这个状态下，codec不再接收输入buffer，但是仍然生成输出buffer，直到遇见输出buffer的end-of-stream标示。在Executing状态下，可以通过调用flush()方法，使codec在任何时候切换回Flushed状态。<br>当调用stop()方法后，codec返回到Uninitialized状态，可以再次Configured。在codec使用结束后，必须调用release()方法释放codec。<br>在极少数情况下，codec可能遇到error进入Error状态。这是队列操作的无效返回值或者exception进行通讯的。这时可以调用reset()方法就可以使codec再次可用，也可以在任何状态下调用reset()方法，使codec返回到Uninitialized状态，否则就应该调用release()方法释放。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>使用MediaCodecList创建一个制定媒体格式（MediaFormat）的MediaCodec。当解码文件或者流时，可以通过MediaExtractor.getTrackFormat获取所需的格式，如果需要注入特定的特性，可以通过MediaFormat.setFeatureEnabled添加；然后调用MediaCodecList.findDecoderForFormat获取能够处理这种媒体格式的codec的名称；最后，使用createByCodecName(String)创建codec。</p>
<blockquote>
<p>注意：在<code>android LOLLIPOP</code>中，给MediaCodecList.findDecoder/EncoderForFormat指定的格式一定不能包含帧速率。使用format.setString(MediaFormat.KEY_FRAME_RATE,null)来清除任何format中存在的帧速率。</p>
</blockquote>
<p>也可以通过createDecoder/EncoderByType(String)创建一个为特定MIME类型格式的codec，但是不能注入特性，而且可能创建一个处理不了指定媒体格式的codec。</p>
<h3 id="创建安全解码器"><a href="#创建安全解码器" class="headerlink" title="创建安全解码器"></a>创建安全解码器</h3><p>在<code>androi KITKAT_WATCH(api 20, 4.4W)</code>及更早的版本中，安全的codec可能不在MediaCodecList中，但是在系统中仍然可用。存在的安全codec可以通过名字+”.secure”(所有的安全codec都必须以”.secure”结尾)进行实例化。如果codec不存在，createByCodecName(String)将抛出一个IOException异常。<br>从<code>Android LOLLIPOP</code>开始，应该在媒体格式中使用FEATURE_SecurePlayback特性创建安全解码器。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>创建codec后，如果要异步处理数据，需要通过setCallback指定一个回调函数,然后使用特定的媒体格式配置一个codec。初始化时可以指定视频源输出到Surface、生成raw格式video data（如 video 解码器），设置安全codec的解码参数。由于某些codec可以在多种模式下运行，所以必须指定是否将其作为一个解码器或者编码器。<br>从<code>android LOLLIPOP</code>，可以在Configured状态查询输入/输出的格式，然后在codec starting之前验证配置结果。<br>如果要用raw video buffer的codec（如video编码器）本地处理raw格式的输入video buffer，可以在配置后通过createInputSurface()为输入数据创建一个目标Surface。或者建立一个codec通过调用setInputSurface(Suface)来使用已经创建过的持久化的输入Surface。</p>
<h3 id="Codec-specific-Data"><a href="#Codec-specific-Data" class="headerlink" title="Codec-specific Data"></a>Codec-specific Data</h3><p>一些格式，特别是AAC音频和MPEG4、H.264、H.265视频格式，要求实际数据要以Codec-specific Data或者buffer包含的设置数据的数字为前缀。处理这些压缩的格式时，Codec-specific Data数据必须在code start()之后、在任何帧数据到来之前提交给codec。在调用queueInputBuffer()时，必须对这些数据进行BUFFER_FLAG_CODEC_CONFIG标示。<br>Codec-specific Data可以包含在传递给带有”csd-0”,”csd-1”等关键字的ByteBuffer条目的配置中，这些关键字始终包含在从MediaExtractor获取的MediaFormat中。格式中的Codec-specific Data在codec start()时会自动提交给codec，不要明确递交。如果格式中不包含，可以根据格式要求，使用buffer指定的数字，用正确的顺序选择提交。在H.264 AVC的情况下，还可以连接所有codec-specific data，并将其作为单个codec-config buffer提交。<br>android中使用如下codec-specific data buffer。这些也需要按照适合MediaMuxer轨道配置的轨道格式进行设置。每个参数集和标有(*)的 codec-specific-data 都必须以起始代码“\ x00 \ x00 \ x00 \ x01”开头。<br><img src="https://i.postimg.cc/tJ8HG70P/Screenshot-2019-07-27-at-15-45-15.png" alt=""></p>
<blockquote>
<p>注意：如果codec在输出buffer或者输出格式更改返回之前或者刚刚start()就被立即flushed，codec specific data可能在flush时丢失，必须使用 BUFFER_FLAG_CODEC_CONFIG标示buffer重新提交codec specific data，以保证codec正常工作。</p>
</blockquote>
<p>编码器（或生成压缩数据的codec）将在标有codec-config标志的输出buffer中的任何有效输出buffer之前创建并返回 codec specific data。 包含codec-specific-data的buffer没有有意义的时间戳。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>在调用api时，每个codec都持有一系列被buffer-ID引用的输入/输出buffer，当成功的start()后，客户端拥有既不输入也不输出的buffer。在同步模式下，调用dequeueInput/OutputBuffer(……)从codec中获取一个输入/输出buffer；在异步模式下，通过MediaCodec.Callback.onInput/OutputBufferAvailable(……)回调函数会自动接收到可用的buffer。<br>在获取输入buffer时，放入数据后通过queueInputBuffer或者queueSecureInputBuffer（如果使用decryption）提交给codec。不要提交多个具有相同时间戳的输入buffer（除非是标记为 codec-specific data）<br>在异步模式下，codec会通过onOutputBufferAvailable回调函数返回一个只读的输出buffer；在同步模式下，调用dequeuOutputBuffer函数获取只读的输出buffer。当输出buffer处理完毕后，调用其中一个的releaseOutputBuffer的方法，将buffer返回给codec。<br>当不需要立即向codec提交或者释放buffer时，持有输入/输出buffer可能造成codec停止，视设备而定。<strong>具体来说，codec可能会推迟生成输出buffer，直到所有未完成的buffer都被提交或者释放</strong>，所以要尽少的持有可用的buffer。<br>根据API的版本，有三种处理数据的方式：<br><img src="https://i.postimg.cc/wxNzDcDQ/Screenshot-2019-07-27-at-16-08-39.png" alt=""></p>
<h3 id="使用Buffers异步处理"><a href="#使用Buffers异步处理" class="headerlink" title="使用Buffers异步处理"></a>使用Buffers异步处理</h3><p>从<code>android LOLLIPOP(api 21, 5.0)</code>开始，首选异步处理数据，在调用configure之前，设置一个回调函数，异步模式下，因为要让codec进入Running子状态接收输入buffer，所以必须在flush()之后调用start()，这就会使codec状态发生改变。同样，在初始调用下启动的codec将会直接进入到Running子状态，通过回调函数开始传递可用的输入buffer。</p>
<p>MediaCodec异步流程<br><img src="https://i.postimg.cc/wMgwyphP/Screenshot-2019-07-27-at-16-08-48.png" alt=""></p>
<p>MediaCodec在异步模式下的用法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</div><div class="line">MediaFormat mOutputFormat; // member variable</div><div class="line">codec.setCallback(new MediaCodec.Callback() &#123;</div><div class="line">  @Override</div><div class="line">  void onInputBufferAvailable(MediaCodec mc, int inputBufferId) &#123;</div><div class="line">    ByteBuffer inputBuffer = codec.getInputBuffer(inputBufferId);</div><div class="line">    // fill inputBuffer with valid data</div><div class="line">    …</div><div class="line">    codec.queueInputBuffer(inputBufferId, …);</div><div class="line">  &#125;</div><div class="line">  @Override</div><div class="line">  void onOutputBufferAvailable(MediaCodec mc, int outputBufferId, …) &#123;</div><div class="line">    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</div><div class="line">    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</div><div class="line">    // bufferFormat is equivalent to mOutputFormat</div><div class="line">    // outputBuffer is ready to be processed or rendered.</div><div class="line">    …</div><div class="line">    codec.releaseOutputBuffer(outputBufferId, …);</div><div class="line">  &#125;</div><div class="line">  @Override</div><div class="line">  void onOutputFormatChanged(MediaCodec mc, MediaFormat format) &#123;</div><div class="line">    // Subsequent data will conform to new format.</div><div class="line">    // Can ignore if using getOutputFormat(outputBufferId)</div><div class="line">    mOutputFormat = format; // option B</div><div class="line">  &#125;</div><div class="line">  @Override</div><div class="line">  void onError(…) &#123;</div><div class="line">    …</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">codec.configure(format, …);</div><div class="line">mOutputFormat = codec.getOutputFormat(); // option B</div><div class="line">codec.start();</div><div class="line">// wait for processing to complete</div><div class="line">codec.stop();</div><div class="line">codec.release();</div></pre></td></tr></table></figure></p>
<h3 id="使用Buffers同步处理"><a href="#使用Buffers同步处理" class="headerlink" title="使用Buffers同步处理"></a>使用Buffers同步处理</h3><p>从<code>android LOLLIPOP</code>开始，即使在同步模式下使用codec也应该通过getInput/OutputBuffer(int)/getInput/OutputImage(int) 来获取输入/输出buffer，这样可以让框架层进行一些优化，如处理动态内容。如果使用getInput/OutputBuffers()则优化将禁用。</p>
<blockquote>
<p>不要同时混用buffer和buffer array的方法，具体来说，只有在start()之后直接调用getInput/OutputBuffers，或者dequeued一个值为 INFO_OUTPUT_FORMAT_CHANGED的输出buffer ID后才能混用。</p>
</blockquote>
<p>MediaCodec在同步模式下的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</div><div class="line">codec.configure(format, …);</div><div class="line">MediaFormat outputFormat = codec.getOutputFormat(); // option B</div><div class="line">codec.start();</div><div class="line">for (;;) &#123;</div><div class="line">  int inputBufferId = codec.dequeueInputBuffer(timeoutUs);</div><div class="line">  if (inputBufferId &gt;= 0) &#123;</div><div class="line">    ByteBuffer inputBuffer = codec.getInputBuffer(…);</div><div class="line">    // fill inputBuffer with valid data</div><div class="line">    …</div><div class="line">    codec.queueInputBuffer(inputBufferId, …);</div><div class="line">  &#125;</div><div class="line">  int outputBufferId = codec.dequeueOutputBuffer(…);</div><div class="line">  if (outputBufferId &gt;= 0) &#123;</div><div class="line">    ByteBuffer outputBuffer = codec.getOutputBuffer(outputBufferId);</div><div class="line">    MediaFormat bufferFormat = codec.getOutputFormat(outputBufferId); // option A</div><div class="line">    // bufferFormat is identical to outputFormat</div><div class="line">    // outputBuffer is ready to be processed or rendered.</div><div class="line">    …</div><div class="line">    codec.releaseOutputBuffer(outputBufferId, …);</div><div class="line">  &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</div><div class="line">    // Subsequent data will conform to new format.</div><div class="line">    // Can ignore if using getOutputFormat(outputBufferId)</div><div class="line">    outputFormat = codec.getOutputFormat(); // option B</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">codec.stop();</div><div class="line">codec.release();</div></pre></td></tr></table></figure></p>
<h3 id="使用Buffer-Arrays同步处理（deprecated）"><a href="#使用Buffer-Arrays同步处理（deprecated）" class="headerlink" title="使用Buffer Arrays同步处理（deprecated）"></a>使用Buffer Arrays同步处理（deprecated）</h3><p>在<code>android KITKAT_WATCH</code>及以前，输入/输出buffer的集合用ByteBuffer[]表示。在start()方法调用成功后，使用 getInput/OutputBuffers()检索数组，用buffer IDs（非负）作为索引，如下面代码所示。注意，尽管数组的大小有一个上限，但是数组的大小和系统使用的输入/输出buffer的数量没有固定的联系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">MediaCodec codec = MediaCodec.createByCodecName(name);</div><div class="line">codec.configure(format, …);</div><div class="line">codec.start();</div><div class="line">ByteBuffer[] inputBuffers = codec.getInputBuffers();</div><div class="line">ByteBuffer[] outputBuffers = codec.getOutputBuffers();</div><div class="line">for (;;) &#123;</div><div class="line">  int inputBufferId = codec.dequeueInputBuffer(…);</div><div class="line">  if (inputBufferId &gt;= 0) &#123;</div><div class="line">    // fill inputBuffers[inputBufferId] with valid data</div><div class="line">    …</div><div class="line">    codec.queueInputBuffer(inputBufferId, …);</div><div class="line">  &#125;</div><div class="line">  int outputBufferId = codec.dequeueOutputBuffer(…);</div><div class="line">  if (outputBufferId &gt;= 0) &#123;</div><div class="line">    // outputBuffers[outputBufferId] is ready to be processed or rendered.</div><div class="line">    …</div><div class="line">    codec.releaseOutputBuffer(outputBufferId, …);</div><div class="line">  &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) &#123;</div><div class="line">    outputBuffers = codec.getOutputBuffers();</div><div class="line">  &#125; else if (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</div><div class="line">    // Subsequent data will conform to new format.</div><div class="line">    MediaFormat format = codec.getOutputFormat();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">codec.stop();</div><div class="line">codec.release();</div></pre></td></tr></table></figure></p>
<h3 id="处理-End-of-stream"><a href="#处理-End-of-stream" class="headerlink" title="处理 End-of-stream"></a>处理 End-of-stream</h3><p>当到达输入数据的末尾时，在调用queueInputBuffer时，必须指定BUFFER_FLAG_END_OF_STREAM标志，发送给codec，可以在最后一个可用的输入buffer或者额外提交一个空的输入buffer设置end-of-stream标志。如果使用空buffer，其时间戳将被忽略。<br>codec会持续返回输出buffer，直到收到带有与MediaCodec.BufferInfo中end-of-stream标志相同的dequeueOutputBuffer或者返回onOutputBufferAvailable时停止，可以在最后一个有效的输出buffer上设置，也可以在最后一个有效输出buffer之后的空buffer中设置。<br>在输入流结束信号发送后，不要再提交额外的输入buffer，除非codec已经flushed or stopped and restarted。</p>
<h3 id="使用输出Surface"><a href="#使用输出Surface" class="headerlink" title="使用输出Surface"></a>使用输出Surface</h3><p>当使用输出Surface时，数据处理和ByteBuffer模式基本相同，但是不能获取输出buffer，值为null，如 getOutputBuffer/Image(int) 将会返回null；getOutputBuffers() 返回一个null数组。<br>使用输出Surface时，可以选择是否在surface上渲染每一个输出buffer，有以下三种方式：</p>
<ul>
<li>不渲染buffer：调用releaseOutputBuffer(bufferId, false)；</li>
<li>根据默认时间戳渲染buffer：调用releaseOutputBuffer(bufferId, true)；</li>
<li>根据指定时间戳渲染buffer：调用releaseOutputBuffer(bufferId, timestamp)。<br>从<code>android M</code>后，默认的时间戳是buffer的显示时间戳（纳秒），之前版本没有定义。另外，<code>android M</code>后，可以通过setOutputSurface动态改变输出Surface。</li>
</ul>
<h3 id="渲染到Surface时的转换"><a href="#渲染到Surface时的转换" class="headerlink" title="渲染到Surface时的转换"></a>渲染到Surface时的转换</h3><p>如果codec配置为Surface模式，任何裁剪矩形、旋转、缩放将会自动应用。</p>
<blockquote>
<p>在<code>android M(api 23, 6.0)</code>之前，渲染到Surface时，软解可能没有应用旋转，也没有标准或者简单的方法识别软解，只能尝试看是否已应用旋转。</p>
</blockquote>
<p>这里有一些需要警告大家的是：</p>
<blockquote>
<p>当渲染到Surface时，像素的长宽比未被考虑。这意味着如果你使用VIDEO_SCALING_MODE_SCALE_TO_FIT模式时，你必须定位输出到Surface，以保证最终恰当的显示长宽比；相反，只能对square pixels的内容(pixel aspect ratio or 1:1)使用VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING模式。</p>
<p>从<code>android N(api 24, 7.0)</code> 开始，视频旋转90或者270度时，VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING模式可能无法正常工作。</p>
<p>当设置视频缩放模式时，注意每次输出buffer更改后都要reset。由于INFO_OUTPUT_BUFFERS_CHANGED事件deprecated，可以在每次输出格式更改后进行reset。</p>
</blockquote>
<h3 id="使用输入Surface"><a href="#使用输入Surface" class="headerlink" title="使用输入Surface"></a>使用输入Surface</h3><p>当使用输入Surface时，没有可访问的输入buffer，这是因为buffer自动的从输入Surface传到codec，调用dequeueInputBuffer将会抛出IllegalStateException异常，getInputBuffers() 返回的是一个不可写的伪ByteBuffer[]。<br>调用 signalEndOfInputStream() 传递 end-of-stream标志后，输入Surface就会停止向codec提交数据。</p>
<h2 id="seeking和自适应播放支持"><a href="#seeking和自适应播放支持" class="headerlink" title="seeking和自适应播放支持"></a>seeking和自适应播放支持</h2><p>无论是否支持并配置为自适应播放，视频解码器（以及一些压缩数据的编码器）在seek和格式更改的行为都不同。可以通过CodecCapatilities.isFeatureSupported(String)检查解码器是否支持自适应播放。视频解码器的自适应播放只有在将codec配置到Surface上时，才会被激活。</p>
<h3 id="流边界和关键帧"><a href="#流边界和关键帧" class="headerlink" title="流边界和关键帧"></a>流边界和关键帧</h3><p>重要的是，在start()或者flush()后输入数据要在合适的流边界开始：第一帧必须是关键帧。<br>关键帧可以通过自身被完全解码（大多数codec的I帧），并且关键帧之后没有帧要显示指的是关键帧之前的帧。<br>下表对不同视频格式合适的关键帧进行了总结：<br><img src="https://i.postimg.cc/TwCD0MzB/Screenshot-2019-07-27-at-16-09-07.png" alt=""></p>
<h3 id="不支持自适应播放的解码器（包括不解码到Surface）"><a href="#不支持自适应播放的解码器（包括不解码到Surface）" class="headerlink" title="不支持自适应播放的解码器（包括不解码到Surface）"></a>不支持自适应播放的解码器（包括不解码到Surface）</h3><p>为了开始解码与之前提交数据不相邻的数据，必须flush解码器。由于所有的输出buffer在flush时被立即撤销，所以需要首先发送信号，等到end-of-stream标志时再flush。重要的是，刷新后的输入数据在合适的流边界/关键帧开始。</p>
<blockquote>
<p>注意，提交数据的格式在flush后必须不能更改，flush() 不支持不连续的格式。对于这种情况，一个完整的stop() - configure(…) - start() 的循环的必要的。<br>同时注意，如果你在start()后flush codec太频繁 - 一般来说，在首次output buffer或output format变更被接收到时 - 你需要重新提交codec-specific-data到codec。可以查看上面关于 codec-specific-data 一块的介绍。</p>
</blockquote>
<h3 id="支持并配置自适应播放的解码器"><a href="#支持并配置自适应播放的解码器" class="headerlink" title="支持并配置自适应播放的解码器"></a>支持并配置自适应播放的解码器</h3><p>为了开始解码与之前提交数据不相邻的数据（如在seek后），不需要flush解码器。这样，输入数据是不连续的，必须从一个合适的流边界/关键帧开始。</p>
<p>对于某些视频格式，即H.264，H.265，VP8和VP9，也可以改变画面大小或配置中间流。为此，须将整个新的codec-specific configuration data与关键帧一起打包到单个buffer（包括任何起始代码）中，并将其作为常规输入buffer提交。<br>在图像大小更改发生之后及在返回新尺寸的任何帧之前，可以从dequeueOutputBuffer或onOutputFormatChanged回调中获得INFO_OUTPUT_FORMAT_CHANGED返回值。</p>
<blockquote>
<p>就像codec-specific configuration data一样，在更改图片大小后不久，调用flush()时要小心,如果没有收到图片尺寸更改的确认，需要重新请求图片大小。</p>
</blockquote>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>工厂方法createByCodecName和createDecoder / EncoderByType抛出IOException异常，必须捕获或声明传递。当不允许该方法调用该codec状态时，MediaCodec方法会抛出IllegalStateException异常，通常是由于应用程序API使用不正确。涉及安全buffer的方法可能会抛出MediaCodec.CryptoException异常，该错误的详细信息可从getErrorCode()获取。<br>内部codec错误导致MediaCodec.CodecException异常，即使应用程序正确使用API，也可能由于媒体内容损坏，硬件故障，资源耗尽等引起此异常。接收到CodecException异常时，建议操作可以通过调用isRecoverable（）和isTransient（）来确定：</p>
<ul>
<li>recoverable errors（可恢复的错误）：如果isRecoverable（）返回true，则调用stop（），configure（…）和start（）来恢复。</li>
<li>transient errors（瞬时错误）:如果isTransient（）返回true，则资源暂时不可用，并且可能会在稍后重试该方法。</li>
<li>fatal errors（致命错误）：如果isRecoverable（）和isTransient（）都返回false，则CodecException是致命的，codec必须reset或released。<br>isRecoverable（）和isTransient（）不会同时返回true</li>
</ul>
<h2 id="有效的API调用及历史"><a href="#有效的API调用及历史" class="headerlink" title="有效的API调用及历史"></a>有效的API调用及历史</h2><p>本节简要说明了在各个状态下有效的API调用以及MediaCodeC的api历史。 API版本可查看<a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="external">Build.VESION_CODES</a></p>
<p><img src="https://i.postimg.cc/ZRB1J4Th/Screenshot-2019-07-27-at-16-20-36.png" alt=""></p>
<p><img src="https://i.postimg.cc/6QSmjgCb/Screenshot-2019-07-27-at-16-24-02.png" alt=""></p>

    </div>

    
    
    

    <footer class="post-footer">
          
        
        <div class="post-tags">
            <a href="/tags/MediaCodeC/" rel="tag"># MediaCodeC</a>
          
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2017/09/19/MediaCodeC-stuff/" rel="next" title="MediaCodeC stuff">
                <i class="fa fa-chevron-left"></i> MediaCodeC stuff
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="Zach Liu">
  <p class="site-author-name" itemprop="name">Zach Liu</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/spiritedRunning" title="GitHub &rarr; https://github.com/spiritedRunning" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Compressed-Buffers"><span class="nav-number">2.1.</span> <span class="nav-text">Compressed Buffers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raw-Audio-Buffers"><span class="nav-number">2.2.</span> <span class="nav-text">Raw Audio Buffers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raw-Video-Buffers"><span class="nav-number">2.3.</span> <span class="nav-text">Raw Video Buffers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在老设备上获取Raw-Video-ByteBuffers"><span class="nav-number">2.4.</span> <span class="nav-text">在老设备上获取Raw Video ByteBuffers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态"><span class="nav-number">3.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建"><span class="nav-number">4.</span> <span class="nav-text">创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建安全解码器"><span class="nav-number">4.1.</span> <span class="nav-text">创建安全解码器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">5.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Codec-specific-Data"><span class="nav-number">5.1.</span> <span class="nav-text">Codec-specific Data</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据处理"><span class="nav-number">6.</span> <span class="nav-text">数据处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Buffers异步处理"><span class="nav-number">6.1.</span> <span class="nav-text">使用Buffers异步处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Buffers同步处理"><span class="nav-number">6.2.</span> <span class="nav-text">使用Buffers同步处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Buffer-Arrays同步处理（deprecated）"><span class="nav-number">6.3.</span> <span class="nav-text">使用Buffer Arrays同步处理（deprecated）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理-End-of-stream"><span class="nav-number">6.4.</span> <span class="nav-text">处理 End-of-stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用输出Surface"><span class="nav-number">6.5.</span> <span class="nav-text">使用输出Surface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染到Surface时的转换"><span class="nav-number">6.6.</span> <span class="nav-text">渲染到Surface时的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用输入Surface"><span class="nav-number">6.7.</span> <span class="nav-text">使用输入Surface</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#seeking和自适应播放支持"><span class="nav-number">7.</span> <span class="nav-text">seeking和自适应播放支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流边界和关键帧"><span class="nav-number">7.1.</span> <span class="nav-text">流边界和关键帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不支持自适应播放的解码器（包括不解码到Surface）"><span class="nav-number">7.2.</span> <span class="nav-text">不支持自适应播放的解码器（包括不解码到Surface）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持并配置自适应播放的解码器"><span class="nav-number">7.3.</span> <span class="nav-text">支持并配置自适应播放的解码器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理"><span class="nav-number">8.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有效的API调用及历史"><span class="nav-number">9.</span> <span class="nav-text">有效的API调用及历史</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zach Liu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">27k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">24 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.3.6</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.2.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  



































    
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'lCyIxTLd0floPkEhLQpxgYsN-gzGzoHsz',
    appKey: 'XOKh4bh1czszmcXQy0tviaoy',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>


</body>
</html>
